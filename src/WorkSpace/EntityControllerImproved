local entity = script.Parent --the entity model

local RunService = game:GetService("RunService") -- more details on this service 
local PathfindingService = game:GetService("PathfindingService")-- roblox's own service that helps with the npc's pathfinding

local NPChumanoid = entity:WaitForChild("Humanoid") -- waiting for the humanoid model to spawn into the world
local rootPart = entity:WaitForChild("HumanoidRootPart") --waiting for the core component of humanoid to be registerd
local wpFolder = workspace:WaitForChild("Waypoints") --loads waypoints folder
local waypoints = wpFolder:GetChildren() --gets all the waypoints
local meshpoint = workspace:WaitForChild("Meshpoints"):GetChildren() --the point the npc walks to

if rootPart then
	rootPart:SetNetworkOwner(nil) -- makes the entity's network owner to the server
end


local players = game:GetService("Players") --roblox servise to retrive all active playyers in game

-- tuning enums 

local PATROL_WAIT = 0.5
local CHASE_RANGE = 40
local ATTACK_RANGE = 4
local ATTACK_DAMAGE = 20
local ATTACK_COOLDOWN = 2

local lastAttack = 0

local currentWp = 1 -- index for wpFolder

local state = 'Patrol' -- fixed state varaibles 

-- simple function to get distance in studs 
local function distanceTo(pos) 
	return (rootPart.Position - pos).Magnitude
end

-- modified the function to get nearest player
local function getNearestPlayer(maxDistToPlyr) 
	local nearest = nil
	local nearestDist = maxDistToPlyr

	-- loops throught all the players in the game
	for _, plr in ipairs(players:GetPlayers()) do 
		local char = plr.Character
		local humanoid = char:FindFirstChild("Humanoid")
		local hrp = char and char:FindFirstChild("HumanoidRootPart")
		-- gets the root part of the player which is used for getting players position
		if humanoid and humanoid.Health > 0 and hrp then 
			--finds distance between the npc and the player
			local dist = distanceTo(char.HumanoidRootPart.Position)
			
			-- checks if the player is in the radius of the npc
			if dist < nearestDist then
				nearestDist = dist
				nearest = plr
			end
		end
	end
	-- then returns the closest player that the NPC tracks
	return nearest
end

--- Collect waypoints and meshpoints
local function combineMeshes()
	local points = {}
	local map = {}
	
	-- Collects all the meshpoints (waypoints and path meshes) in the map
	for _, wpoint in ipairs(waypoints) do
		table.insert(points, wpoint)
	end
	for _, mpoint in ipairs(meshpoint) do
		table.insert(points, mpoint)
	end
	
	-- Creates a table of the points with the instance's name, which will be used
	for _, point in ipairs(points) do
		map[point.Name] = point
	end
	
	return points, map
end

-- returns a tables of all the points and a map of the points
local allpoints, meshMap = combineMeshes() 

-- this piece of code gets the closest meshpoint to the entity
local function getNearestMesh()
	local nearest = nil
	local nearestDistance = math.huge
	
	for _, point in ipairs(allpoints) do
		local dist = (entity.PrimaryPart.Position - point.Position).Magnitude
		if dist < nearestDistance then
			nearestDistance = dist
			nearest = point
		end
	end
	
	return nearest
end

-- graph of meshpoints, with room weights
local graph = {
	["RoomB"] = {["RoomA"]=1},
	["RoomA"] = {["CorrA"]=2, ["CorrB"]=1, ["RoomB"]=1},
	["CorrA"] = {["CorrB"]=1, ["RoomA"]=2},
	["CorrB"] = {["CorrA"]=1, ["RoomA"]=1, ["Wp1"]=1},
	["CorrC"] = {["Wp1"]=1},
	["Wp1"]  = {["CorrB"]=1, ["CorrC"]=1}
}

-- Dijkstra's algorithm to find the shortest path to the the patrol point
local function dijkstra(graph, startNode, goalNode)
	local distances = {}
	local previous = {}
	local visited = {}
	
	for node,_ in pairs(graph) do
		-- sets all the distances to infinity
		distances[node] = math.huge
		-- sets all the previous nodes to nil
		previous[node] = nil
	end
	-- sets the distance of the start node to 0
	distances[startNode] = 0
	
	-- main dijkstra loop
	while true do
		local closest = nil
		local closestDistance = math.huge
		
		-- finds the closest node to the start node
		for node, dist in pairs(distances) do
			if not visited[node] and dist < closestDistance then
				closest = node
				closestDistance = dist
			end
		end
		
		-- if there is no closer node then break
		if not closest then 
			break 
		end
		
		-- if closest is the goal node then break
		if closest == goalNode then
			break
		end
		
		-- mark the closest node as visited
		visited[closest] = true
		
		-- check all the neighbours of the closest node
		for neighbour, weight in pairs(graph[closest]) do
			-- if the distance to the neighbour is greater than the distance to the closest node + the weight of the edge then update the distance
			local newDist = distances[closest] + weight
			if newDist < distances[neighbour] then
				-- distance of the neighbour set to the new distance
				distances[neighbour] = newDist
				-- previous node of the neighbour set to the closest node
				previous[neighbour] = closest
			end
		end
	end

	-- reconstruct path
	local path = {}
	local current = goalNode
	while current do
		table.insert(path, 1, current)
		current = previous[current]
	end
	
	--r eturs path
	return path
end

-- using the Roblox's pathfinding tool, we generate a path that creates a table of waypoints
local function followPath(path, chaseRange)
	local waypoints = path:GetWaypoints()
	for _, wp in ipairs(waypoints) do
		-- incase player gets back in range, we check if the player is still in range
		local target = getNearestPlayer(chaseRange)
		if target then
			state = "Chase"
			return true
		end
		
		-- uses the table of paths to move the NPC
		NPChumanoid:MoveTo(wp.Position)
		NPChumanoid.MoveToFinished:Wait(0.05)
	end
	return false
end

while true do
	-- Check for player
	local target = getNearestPlayer(CHASE_RANGE)
	if state == "Patrol" then
		if target then
			state = "Chase"
		else
			-- Move to next waypoint
			local wp = waypoints[currentWp] --index 1 of wp
			NPChumanoid:MoveTo(wp.Position)
			
			local reached = false
			
			-- check if the NPC reached the waypoint
			local connection
			connection = NPChumanoid.MoveToFinished:Connect(function(success)
				reached = true
				connection:Disconnect()
			end) 
			
			
			while not reached do
				-- checks for player while traversing patrol points
				local newTarget = getNearestPlayer(CHASE_RANGE)
				if newTarget then
					-- sets state to chase and stops moving to waypoint
					state = "Chase"
					if connection then connection:Disconnect() end
					break
				end
				task.wait(0.1)
			end
			
			-- if state is patrol, move to next waypoint
			if state == "Patrol" then
				currentWp += 1
				if currentWp > #waypoints then
					currentWp = 1 --reset wp if completed
				end
				wait(PATROL_WAIT)
			end
		end

	elseif state == "Chase" then
		-- if no target is found, return state
		if not target then
			state = "Return"
		else
			local char = target.Character -- get the character of the target
			local hrp = char and char:FindFirstChild("HumanoidRootPart") -- get the humanoid root part of the target player
			if hrp then
				local dist = (NPChumanoid.RootPart.Position - hrp.Position).Magnitude -- calculate distance between NPC and player

				-- attack switch
				if dist <= ATTACK_RANGE then
					state = "Attack"
					
				-- chase logic
				else
					-- used to check if there is a wall in front of the NPC 
					local direction = (hrp.Position - NPChumanoid.RootPart.Position).Unit
					local ray = Ray.new(NPChumanoid.RootPart.Position, direction * 3)
					local hit = workspace:FindPartOnRay(ray, NPChumanoid.Parent)

					-- Wall detected: path around
					if hit then
						local path = PathfindingService:CreatePath({
							AgentRadius = 2,
							AgentHeight = 5,
							CanJump = false,
							WaypointSpacing = 4
						})
						
						-- to catch errors
						local success, err = pcall(function()
							-- computes the path between the NPC and the player
							path:ComputeAsync(NPChumanoid.RootPart.Position, hrp.Position)
						end)
						
						
						if path.Status == Enum.PathStatus.Success and success then
							-- follow the path to the players waypoints
							for _, wp in ipairs(path:GetWaypoints()) do
								NPChumanoid:MoveTo(wp.Position)
								NPChumanoid.MoveToFinished:Wait(0.2)
								-- if player in range, attack!
								if (hrp.Position - NPChumanoid.RootPart.Position).Magnitude <= ATTACK_RANGE then
									state = "Attack"
									break
								end
							end
						end
					else
						-- No wall: simple MoveTo update
						NPChumanoid:MoveTo(hrp.Position)
						task.wait(0.2)
					end
				end
			else
				-- if no humanoid root part, return to patrol
				state = "Patrol"
			end
		end
	-- basic attack logic
	elseif state == "Attack" then
		print("Jump scare now!")
		if target then
			local char = target.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")
			local hum = char and char:FindFirstChild("Humanoid")

			if hrp and hum then
				--check cooldown timer
				if tick() - lastAttack >= ATTACK_COOLDOWN then
					hum:TakeDamage(ATTACK_DAMAGE)
					-- TEMPORARY COMMENTED OUT: print('Entity attacked: '..target.Name..'for'..ATTACK_DAMAGE..'damage!')
					lastAttack = tick()
				end
			end
		end

		wait(1)
		state = "Patrol"
	
	-- return logic
	elseif state == "Return" then
		local nearestMesh = getNearestMesh() --gets the closest mesh to the entity
		
		if nearestMesh.Name == 'Wp1' or nearestMesh.Name == 'Wp2' or nearestMesh.Name == 'Wp3' then
			local path = PathfindingService:CreatePath({
				AgentRadius = 2,
				AgentHeight = 5,
				CanJump = false,
				WaypointSpacing = 4
			})


			local success, err = pcall(function()
				path:ComputeAsync(NPChumanoid.RootPart.Position, nearestMesh.Position)
			end)

			if path.Status == Enum.PathStatus.Success and success then
				local switched = followPath(path, CHASE_RANGE)
				if switched then
					foundTarget = true
					break
				end
			else
				warn("Path failed")
			end
			state = "Patrol" --if the closest mesh is a waypoint, return to patrol
			currentWp = 1 --reset wp if completed
		else
			local pathNodes = dijkstra(graph, nearestMesh.Name, "Wp1") --returns a table that contains the path to the patrol point
			print("Pathback:", table.concat(pathNodes))
			
			local foundTarget = false
			
			-- follow the path to the nearest mesh
			for i = 1, #pathNodes-1 do
				local startNode = meshMap[pathNodes[i]] -- current node
				local endNode = meshMap[pathNodes[i+1]] -- next node
				
				-- pathing logic
				if startNode and endNode then 
					-- check for players in range, in case player is in range again, chase them
					local target = getNearestPlayer(CHASE_RANGE)
					
					-- set to chase state
					if target then
						state = "Chase"
						foundTarget = true
						break
					end
					
					
					local fromPos
					if i == 1 and NPChumanoid and NPChumanoid.RootPart then
						fromPos = NPChumanoid.RootPart.Position
					else
						fromPos = startNode.Position
					end
					
					local path = PathfindingService:CreatePath({
						AgentRadius = 2,
						AgentHeight = 5,
						CanJump = false,
						WaypointSpacing = 4})
					
					-- pcall() to catch errors
					local success, err = pcall(function()
						-- computes the path between the NPC and the player
						path:ComputeAsync(fromPos, endNode.Position)
					end)
					
					-- outputs failure of path computation (for testing)
					if not success then
						warn("Path compute failed:", err)
						continue
					end
					
					-- pcall() to catch errors
					local success, err = pcall(function()
						-- computes the path between the NPC and the player
						path:ComputeAsync(fromPos, endNode.Position)
					end)

					-- outputs failure of path computation (for testing)
					if success and path.Status == Enum.PathStatus.Success then
						local switched = followPath(path, CHASE_RANGE)
						if switched then
							foundTarget = true
							break
						end
					else
						warn("Path compute failed:", err)
					end
				else
					warn("Start or end node not found:", pathNodes[i], pathNodes[i+1])
				end
			end
			-- set state back to patrol after returning to patrol point
			state = "Patrol"
			currentWp = 1
		end
	end
	
	task.wait(0.05)
	RunService.Heartbeat:Wait() --updates throttle synced to game frames 
end
